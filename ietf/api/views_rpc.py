# Copyright The IETF Trust 2023-2025, All Rights Reserved

import datetime
import json
from typing import Literal, Optional

from drf_spectacular.utils import OpenApiParameter
from rest_framework import serializers, viewsets, mixins
from rest_framework.decorators import action
from rest_framework.views import APIView
from rest_framework.response import Response

from django.db.models import OuterRef, Subquery, Q
from django.http import (
    HttpResponseBadRequest,
    JsonResponse,
    HttpResponseNotAllowed,
    Http404,
)
from django.views.decorators.csrf import csrf_exempt
from drf_spectacular.utils import extend_schema_view, extend_schema
from rest_framework import generics
from rest_framework.fields import CharField
from rest_framework.filters import SearchFilter
from rest_framework.pagination import LimitOffsetPagination

from ietf.api.serializers_rpc import (
    PersonSerializer,
    FullDraftSerializer,
    DraftSerializer,
)
from ietf.doc.models import Document, DocHistory, RelatedDocument
from ietf.person.models import Email, Person
from .ietf_utils import requires_api_token


@extend_schema_view(
    retrieve=extend_schema(
        operation_id="get_person_by_id",
        summary="Find person by ID",
        description="Returns a single person",
    ),
    batch=extend_schema(
        operation_id="get_persons",
        summary="Get a batch of persons",
        description="Returns a list of persons matching requested ids. Omits any that are missing.",
        request=list[int],
        responses=PersonSerializer(many=True),
    ),
)
class PersonViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    queryset = Person.objects.all()
    serializer_class = PersonSerializer
    api_key_endpoint = "ietf.api.views_rpc"
    lookup_url_kwarg = "person_id"

    @action(detail=False, methods=["post"], serializer_class=PersonSerializer)
    def batch(self, request):
        """Get a batch of rpc person names"""
        pks = request.data
        return Response(
            self.get_serializer(Person.objects.filter(pk__in=pks), many=True).data
        )


class SubjectPersonView(APIView):
    api_key_endpoint = "ietf.api.views_rpc"

    @extend_schema(
        operation_id="get_subject_person_by_id",
        summary="Find person for OIDC subject by ID",
        description="Returns a single person",
        responses=PersonSerializer,
        parameters=[
            OpenApiParameter(
                name="subject_id",
                type=str,
                description="subject ID of person to return",
                location="path",
            ),
        ],
    )
    def get(self, request, subject_id: str):
        try:
            user_id = int(subject_id)
        except ValueError:
            raise serializers.ValidationError({"subject_id": "This field must be an integer value."})
        person = Person.objects.filter(user__pk=user_id).first()
        if person:
            return Response(PersonSerializer(person).data)
        raise Http404


class RpcLimitOffsetPagination(LimitOffsetPagination):
    default_limit = 10
    max_limit = 100


class SingleTermSearchFilter(SearchFilter):
    """SearchFilter backend that does not split terms
    
    The default SearchFilter treats comma or whitespace-separated terms as individual
    search terms. This backend instead searches for the exact term.
    """

    def get_search_terms(self, request):
        value = request.query_params.get(self.search_param, '')
        field = CharField(trim_whitespace=False, allow_blank=True)
        cleaned_value = field.run_validation(value)
        return [cleaned_value]


@extend_schema_view(
    get=extend_schema(
        operation_id="search_person",
        description="Get a list of persons, matching by partial name or email",
    ),
)
class RpcPersonSearch(generics.ListAPIView):
    # n.b. the OpenAPI schema for this can be generated by running
    # ietf/manage.py spectacular --file spectacular.yaml
    # and extracting / touching up the rpc_person_search_list operation
    api_key_endpoint = "ietf.api.views_rpc"
    queryset = Person.objects.all()
    serializer_class = PersonSerializer
    pagination_class = RpcLimitOffsetPagination

    # Searchable on all name-like fields or email addresses
    filter_backends = [SingleTermSearchFilter]
    search_fields = ["name", "plain", "email__address"]



class SubmittedToQueueSerializer(FullDraftSerializer):
    submitted = serializers.SerializerMethodField()

    class Meta:
        model = Document
        fields = [
            "id",
            "name",
            "stream",
            "submitted",
        ]


    def get_submitted(self, doc) -> Optional[datetime.datetime]:
        event = doc.sent_to_rfc_editor_event()
        return None if event is None else event.time


@extend_schema_view(
    retrieve=extend_schema(
        operation_id="get_draft_by_id",
        summary="Get a draft",
        description="Returns the draft for the requested ID",
    ),
    submitted_to_rpc=extend_schema(
        operation_id="submitted_to_rpc",
        summary="List documents ready to enter the RFC Editor Queue",
        description="List documents ready to enter the RFC Editor Queue",
        responses=SubmittedToQueueSerializer(many=True),
    )
)
class DraftViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    queryset = Document.objects.filter(type_id="draft")
    serializer_class = FullDraftSerializer
    api_key_endpoint = "ietf.api.views_rpc"
    lookup_url_kwarg = "doc_id"

    @action(detail=False, serializer_class=SubmittedToQueueSerializer)
    def submitted_to_rpc(self, request):
        """Return documents in datatracker that have been submitted to the RPC but are not yet in the queue

        Those queries overreturn - there may be things, particularly not from the IETF stream that are already in the queue.
        """
        ietf_docs = Q(states__type_id="draft-iesg", states__slug__in=["ann"])
        irtf_iab_ise_docs = Q(
            states__type_id__in=[
                "draft-stream-iab",
                "draft-stream-irtf",
                "draft-stream-ise",
            ],
            states__slug__in=["rfc-edit"],
        )
        # TODO: Need a way to talk about editorial stream docs
        docs = self.get_queryset().filter(type_id="draft").filter(
            ietf_docs | irtf_iab_ise_docs
        )
        serializer = self.get_serializer(docs, many=True)
        return Response(serializer.data)



@csrf_exempt
@requires_api_token("ietf.api.views_rpc")
def rpc_draft_refs(request, doc_id):
    """Return normative references"""
    if request.method != "GET":
        return HttpResponseNotAllowed(["GET"])

    return JsonResponse(
        dict(
            references=[
                dict(id=t[0], name=t[1])
                for t in RelatedDocument.objects.filter(
                    source_id=doc_id, target__type_id="draft", relationship_id="refnorm"
                ).values_list("target_id", "target__name")
            ]
        )
    )


class DraftsByNamesView(APIView):
    api_key_endpoint = "ietf.api.views_rpc"

    @extend_schema(
        operation_id="get_drafts_by_names",
        summary="Get a batch of drafts by draft names",
        description="returns a list of drafts with matching names",
        request=list[str],
        responses=DraftSerializer(many=True)
    )
    def post(self, request):
        names = request.data
        docs = Document.objects.filter(type_id="draft", name__in=names)
        return Response(DraftSerializer(docs, many=True).data)


@csrf_exempt
@requires_api_token("ietf.api.views_rpc")
def rfc_original_stream(request):
    """Return the stream that an rfc was first published into for all rfcs"""
    rfcs = Document.objects.filter(type="rfc").annotate(
        orig_stream_id=Subquery(
            DocHistory.objects.filter(doc=OuterRef("pk"))
            .exclude(stream__isnull=True)
            .order_by("time")
            .values_list("stream_id", flat=True)[:1]
        )
    )
    response = {"original_stream": []}
    for rfc in rfcs:
        response["original_stream"].append(
            {
                "rfc_number": rfc.rfc_number,
                "stream": (
                    rfc.orig_stream_id
                    if rfc.orig_stream_id is not None
                    else rfc.stream_id
                ),
            }
        )
    return JsonResponse(response)


@csrf_exempt
@requires_api_token("ietf.api.views_rpc")
def persons_by_email(request):
    if request.method != "POST":
        return HttpResponseNotAllowed(["POST"])
    try:
        emails = json.loads(request.body)
    except json.JSONDecodeError:
        return HttpResponseBadRequest()
    response = []
    for email in Email.objects.filter(address__in=emails).exclude(person__isnull=True):
        response.append(
            {
                "email": email.address,
                "person_pk": email.person.pk,
                "name": email.person.name,
                "last_name": email.person.last_name(),
                "initials": email.person.initials(),
            }
        )
    return JsonResponse(response, safe=False)


@csrf_exempt
@requires_api_token("ietf.api.views_rpc")
def rfc_authors(request):
    """Gather authors of the RFCs with the given numbers"""
    if request.method != "POST":
        return HttpResponseNotAllowed(["POST"])
    try:
        rfc_numbers = json.loads(request.body)
    except json.JSONDecodeError:
        return HttpResponseBadRequest()
    response = []
    for rfc in Document.objects.filter(type="rfc", rfc_number__in=rfc_numbers):
        item = {"rfc_number": rfc.rfc_number, "authors": []}
        for author in rfc.authors():
            item_author = dict()
            item_author["person_pk"] = author.pk
            item_author["name"] = author.name
            item_author["last_name"] = author.last_name()
            item_author["initials"] = author.initials()
            item_author["email_addresses"] = [
                address.lower()
                for address in author.email_set.values_list("address", flat=True)
            ]
            item["authors"].append(item_author)
        response.append(item)
    return JsonResponse(response, safe=False)


@csrf_exempt
@requires_api_token("ietf.api.views_rpc")
def draft_authors(request):
    """Gather authors of the RFCs with the given numbers"""
    if request.method != "POST":
        return HttpResponseNotAllowed(["POST"])
    try:
        draft_names = json.loads(request.body)
    except json.JSONDecodeError:
        return HttpResponseBadRequest()
    response = []
    for draft in Document.objects.filter(type="draft", name__in=draft_names):
        item = {"draft_name": draft.name, "authors": []}
        for author in draft.authors():
            item_author = dict()
            item_author["person_pk"] = author.pk
            item_author["name"] = author.name
            item_author["last_name"] = author.last_name()
            item_author["initials"] = author.initials()
            item_author["email_addresses"] = [
                address.lower()
                for address in author.email_set.values_list("address", flat=True)
            ]
            item["authors"].append(item_author)
        response.append(item)
    return JsonResponse(response, safe=False)
