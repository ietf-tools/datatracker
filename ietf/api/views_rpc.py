# Copyright The IETF Trust 2023-2025, All Rights Reserved

from drf_spectacular.utils import OpenApiParameter
from rest_framework import serializers, viewsets, mixins
from rest_framework.decorators import action
from rest_framework.views import APIView
from rest_framework.response import Response

from django.db.models import CharField as ModelCharField, OuterRef, Subquery, Q
from django.db.models.functions import Coalesce
from django.http import Http404
from drf_spectacular.utils import extend_schema_view, extend_schema
from rest_framework import generics
from rest_framework.fields import CharField as DrfCharField
from rest_framework.filters import SearchFilter
from rest_framework.pagination import LimitOffsetPagination

from ietf.api.serializers_rpc import (
    PersonSerializer,
    FullDraftSerializer,
    DraftSerializer,
    SubmittedToQueueSerializer,
    OriginalStreamSerializer,
    ReferenceSerializer,
    EmailPersonSerializer,
    RfcWithAuthorsSerializer,
    DraftWithAuthorsSerializer,
)
from ietf.doc.models import Document, DocHistory
from ietf.person.models import Email, Person


@extend_schema_view(
    retrieve=extend_schema(
        operation_id="get_person_by_id",
        summary="Find person by ID",
        description="Returns a single person",
    ),
)
class PersonViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    queryset = Person.objects.all()
    serializer_class = PersonSerializer
    api_key_endpoint = "ietf.api.views_rpc"
    lookup_url_kwarg = "person_id"

    @extend_schema(
        operation_id="get_persons",
        summary="Get a batch of persons",
        description="Returns a list of persons matching requested ids. Omits any that are missing.",
        request=list[int],
        responses=PersonSerializer(many=True),
    )
    @action(detail=False, methods=["post"])
    def batch(self, request):
        """Get a batch of rpc person names"""
        pks = request.data
        return Response(
            self.get_serializer(Person.objects.filter(pk__in=pks), many=True).data
        )

    @extend_schema(
        operation_id="persons_by_email",
        summary="Get a batch of persons by email addresses",
        description=(
            "Returns a list of persons matching requested ids. "
            "Omits any that are missing."
        ),
        request=list[str],
        responses=EmailPersonSerializer(many=True),
    )
    @action(detail=False, methods=["post"], serializer_class=EmailPersonSerializer)
    def batch_by_email(self, request):
        emails = Email.objects.filter(address__in=request.data, person__isnull=False)
        serializer = self.get_serializer(emails, many=True)
        return Response(serializer.data)


class SubjectPersonView(APIView):
    api_key_endpoint = "ietf.api.views_rpc"

    @extend_schema(
        operation_id="get_subject_person_by_id",
        summary="Find person for OIDC subject by ID",
        description="Returns a single person",
        responses=PersonSerializer,
        parameters=[
            OpenApiParameter(
                name="subject_id",
                type=str,
                description="subject ID of person to return",
                location="path",
            ),
        ],
    )
    def get(self, request, subject_id: str):
        try:
            user_id = int(subject_id)
        except ValueError:
            raise serializers.ValidationError(
                {"subject_id": "This field must be an integer value."}
            )
        person = Person.objects.filter(user__pk=user_id).first()
        if person:
            return Response(PersonSerializer(person).data)
        raise Http404


class RpcLimitOffsetPagination(LimitOffsetPagination):
    default_limit = 10
    max_limit = 100


class SingleTermSearchFilter(SearchFilter):
    """SearchFilter backend that does not split terms

    The default SearchFilter treats comma or whitespace-separated terms as individual
    search terms. This backend instead searches for the exact term.
    """

    def get_search_terms(self, request):
        value = request.query_params.get(self.search_param, "")
        field = DrfCharField(trim_whitespace=False, allow_blank=True)
        cleaned_value = field.run_validation(value)
        return [cleaned_value]


@extend_schema_view(
    get=extend_schema(
        operation_id="search_person",
        description="Get a list of persons, matching by partial name or email",
    ),
)
class RpcPersonSearch(generics.ListAPIView):
    # n.b. the OpenAPI schema for this can be generated by running
    # ietf/manage.py spectacular --file spectacular.yaml
    # and extracting / touching up the rpc_person_search_list operation
    api_key_endpoint = "ietf.api.views_rpc"
    queryset = Person.objects.all()
    serializer_class = PersonSerializer
    pagination_class = RpcLimitOffsetPagination

    # Searchable on all name-like fields or email addresses
    filter_backends = [SingleTermSearchFilter]
    search_fields = ["name", "plain", "email__address"]


@extend_schema_view(
    retrieve=extend_schema(
        operation_id="get_draft_by_id",
        summary="Get a draft",
        description="Returns the draft for the requested ID",
    ),
    submitted_to_rpc=extend_schema(
        operation_id="submitted_to_rpc",
        summary="List documents ready to enter the RFC Editor Queue",
        description="List documents ready to enter the RFC Editor Queue",
        responses=SubmittedToQueueSerializer(many=True),
    ),
)
class DraftViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    queryset = Document.objects.filter(type_id="draft")
    serializer_class = FullDraftSerializer
    api_key_endpoint = "ietf.api.views_rpc"
    lookup_url_kwarg = "doc_id"

    @action(detail=False, serializer_class=SubmittedToQueueSerializer)
    def submitted_to_rpc(self, request):
        """Return documents in datatracker that have been submitted to the RPC but are not yet in the queue

        Those queries overreturn - there may be things, particularly not from the IETF stream that are already in the queue.
        """
        ietf_docs = Q(states__type_id="draft-iesg", states__slug__in=["ann"])
        irtf_iab_ise_docs = Q(
            states__type_id__in=[
                "draft-stream-iab",
                "draft-stream-irtf",
                "draft-stream-ise",
            ],
            states__slug__in=["rfc-edit"],
        )
        # TODO: Need a way to talk about editorial stream docs
        docs = (
            self.get_queryset()
            .filter(type_id="draft")
            .filter(ietf_docs | irtf_iab_ise_docs)
        )
        serializer = self.get_serializer(docs, many=True)
        return Response(serializer.data)

    @extend_schema(
        operation_id="get_draft_references",
        summary="Get normative references to I-Ds",
        description=(
            "Returns the id and name of each normatively "
            "referenced Internet-Draft for the given docId"
        ),
        responses=ReferenceSerializer(many=True),
    )
    @action(detail=True, serializer_class=ReferenceSerializer)
    def references(self, request, doc_id=None):
        doc = self.get_object()
        serializer = self.get_serializer(
            [
                reference
                for reference in doc.related_that_doc("refnorm")
                if reference.type_id == "draft"
            ],
            many=True,
        )
        return Response(serializer.data)

    @extend_schema(
        operation_id="get_draft_authors",
        summary="Gather authors of the drafts with the given names",
        description="returns a list mapping draft names to objects describing authors",
        request=list[str],
        responses=DraftWithAuthorsSerializer(many=True),
    )
    @action(detail=False, methods=["post"], serializer_class=DraftWithAuthorsSerializer)
    def authors(self, request):
        drafts = self.get_queryset().filter(name__in=request.data)
        serializer = self.get_serializer(drafts, many=True)
        return Response(serializer.data)


@extend_schema_view(
    rfc_original_stream=extend_schema(
        operation_id="get_rfc_original_streams",
        summary="Get the streams RFCs were originally published into",
        description="returns a list of dicts associating an RFC with its originally published stream",
        responses=OriginalStreamSerializer(many=True),
    )
)
class RfcViewSet(viewsets.GenericViewSet):
    queryset = Document.objects.filter(type_id="rfc")
    api_key_endpoint = "ietf.api.views_rpc"

    @action(detail=False, serializer_class=OriginalStreamSerializer)
    def rfc_original_stream(self, request):
        rfcs = self.get_queryset().annotate(
            orig_stream_id=Coalesce(
                Subquery(
                    DocHistory.objects.filter(doc=OuterRef("pk"))
                    .exclude(stream__isnull=True)
                    .order_by("time")
                    .values_list("stream_id", flat=True)[:1]
                ),
                "stream_id",
                output_field=ModelCharField(),
            ),
        )
        serializer = self.get_serializer(rfcs, many=True)
        return Response(serializer.data)

    @extend_schema(
        operation_id="get_rfc_authors",
        summary="Gather authors of the RFCs with the given numbers",
        description="returns a list mapping rfc numbers to objects describing authors",
        request=list[int],
        responses=RfcWithAuthorsSerializer(many=True),
    )
    @action(detail=False, methods=["post"], serializer_class=RfcWithAuthorsSerializer)
    def bulk_authors(self, request):
        rfcs = self.get_queryset().filter(rfc_number__in=request.data)
        serializer = self.get_serializer(rfcs, many=True)
        return Response(serializer.data)


class DraftsByNamesView(APIView):
    api_key_endpoint = "ietf.api.views_rpc"

    @extend_schema(
        operation_id="get_drafts_by_names",
        summary="Get a batch of drafts by draft names",
        description="returns a list of drafts with matching names",
        request=list[str],
        responses=DraftSerializer(many=True),
    )
    def post(self, request):
        names = request.data
        docs = Document.objects.filter(type_id="draft", name__in=names)
        return Response(DraftSerializer(docs, many=True).data)
